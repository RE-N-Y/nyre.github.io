---
layout: single
title: "To Newcomers in CS"
classes: wide
---

Every year, hundreds, thousands, and millions of students enter university to study _Computer Science_. Reasons for deciding to study computer science are different. However, it's undeniable that CS enrollment has been increasingly fueled by _hype_ growing role of computing in modern society. The steam generated by media hype and exponential growth has clouded the current landscape of computing. As a result, newcomers to the field of CS are greeted with a confusing scene where students are introduced to theory, tools, and practices in computing, but have no clear understanding of how these components fit together.

Navigating through this field is difficult. The goal of this article is to paint a landscape of computer science and distill lessons I have learned over years of studying in these fields. But, firstly, I would like to clarify misconceptions that fresh young minds may have about CS.

## Misconceptions about CS

### Coding is not for everyone

Firstly, I DO NOT believe that "Everyone can code". Yes, even a cat can walk over my keyboard and type a sensible, compilable code given enough time. The question is "Can everyone become a good coder?" The answer is "NO". Given enough practice and patience, "anyone" can indeed become a good coder, but an individual also has to find passion in coding.

From personal experience, coders find passion in problems and questions that others find mundane.

Let's take a look at following grid:

![percolation](https://michaeltoth.me/images/percolation.png){: .align-center }

Imagine that a stream of water is flowing top to bottom. In our grid, water would be able to flow from the top and exit to the bottom. Now, given a grid, can we build a program that checks whether water can penetrate to the bottom? If so, what would be the fastest algorithm? Can we prove our algorithm is most efficient? How can we make it use less memory?

**Most importantly, does this problem sound exciting to you?**

These are problems and questions that computer scientists are interested in exploring. We find enjoyment in optimization and finding elegant solutions in computational problems, but, understandably, not "everyone" might find it so fascinating.

Surely, everyone can code, but not everyone will find a passion for coding.

### Coding is paintful

Coding is painful. Often in media, I see that programmers are portrayed in the following manner.

![typing](https://i.pinimg.com/originals/0f/b9/4d/0fb94dff52a5935e105ec497a0c010a5.gif){: .align-center }

Apart from the fact that movie directors think the speed of typing correlates with one's ability to write good code, this portrayal is far from the daily life of coders.

Computers are simplistic, deterministic machines. Naturally, these devils are brutally honest about our mistakes. One mistyped semi-colon, one line, one file can break the entire system. You're constantly battling against an infinite stream of bugs. For most parts, developers spend their time staring at a monitor in distress hunting down bugs, trapped in a perpetual cycle of pain and suffering.

However, the resolution at the end is truly rewarding. It's genuinely satisfying to struggle hours, days, and weeks on a problem in determination and finally see your program run successfully. Moreover, it's a true pleasure to slowly, but steadily get closer and closer to the root cause of a problem. It's almost comparable to solving a murder case except the victim is one's mental sanity.

**Coding is a marathon, not a sprint.** It takes determination and patience to sit down for hours debugging and testing, but for those who can endure and push through frustration, coding is nothing short of pure entertainment.

## Rules of the Game

### Life

#### Rule 1.1: Time is Gold

Time is Gold. 18 ~ 30 is a prime age to acquire knowledge, but it goes fast. Faster than anyone can imagine. A day seems to last forever, but a year goes in a blink of an eye. Always remember that time is an irreplaceable resource.

**Not to plan is planning for death.**

#### Rule 1.2: Be honest

Seriously, be honest.

Don't lie to yourself that you're on track when you're procrastinating.

Don't lie to yourself that you're ready for an exam when you're not.

Don't lie to yourself that you're fine when you've been pulling all-nighters.

Don't lie to yourself. Honesty can take one a long way.

#### Rule 1.3: Sleep

Lack of sleep is a constant problem for any university student. I recommend getting 5 hours of sleep to stay functional. A sleep-deprived brain is inefficient and is a time-consuming machine. Finishing an assignment at 6 am after getting sleep and rest has served me well compared to pulling all-nighters and producing sub-standard work.

#### Rule 1.4: Work is Sacred

Separating **WORK** and **REST** is essential.

Often, people claim that they're "working" while checking social media every 5 minutes or chatting with their friends once in a while. This form of "work" extends the work hours. As a consequence, you find yourself working past midnight. Although you've taken breaks here and there while you were working, you feel that you're still exhausted because they weren't proper breaks.

Try to maintain "uninterrupted" work and "uninterrupted" breaks. I'm not implying that you have to work 3~4 hours straight, take 10~30 minutes of breaks in between. But, when you're working, focus sorely on your work, and when you're taking a break, sorely focus on resting.

Properly separating work and break makes work time shorter and more productive and makes the break feel well-deserved.

#### Rule 1.5: Drink Coffee

Coffee is good, Good is Coffee.

### Learning

#### Rule 2.1: Replicate knowledge

Way too often, some students think reading through their notes and nodding their heads is enough to truly understand the content. Here's a simple assessment to check whether a person "truly" understands a concept.

> Take a blank sheet of paper and write down what you know about the concept.
> What you have on the blank piece of paper is what you "truly" understand.

By the end of a course, try lying back on your bed with eyes closed and try to replicate everything you have learned from the first day to the last day of class. Not only this is a perfect way to organize what you've learned in the course, but also a realistic indicator of what you've learned.

#### Rule 2.2: Organize knowledge

Knowledge is not an array of random facts. Always categorize, connect, and organize the content given to you. Observe the branches, trunks, and roots of how each component fits and supports individual parts. Diagrams, graphs, tables, mindmaps, and narratives are more memorable than a static list of stale text.

At the end of a course, have a single-page summary that narrates how the contents are connected and supported together. Before an exam, make a cheatsheet to organize it in a digestible format. Even if you forget certain parts, if you remember the big picture, it's easy to fill in the blank spots.

#### Rule 2.3: Be a Teacher

Teaching a concept to another person has always helped me to stay sharp on the subject. The reason is simple. To teach a concept, you must have a perfect grasp of the topic.

#### Rule 2.4: Preview, Review

I know it sounds cliche, but preview and review the content before going to class. Going into class already having a basic understanding of content makes hard classes a lot easier to digest and follow up. Moreover, it ultimately saves you time because you're not left confused in the middle of class to bearly keep up with content.

### Computer Science

#### Rule 3.1: Practice makes perfect

In Computer Science, students are presented with algorithms in the abstract, generic description. But, try to apply the algorithm on concrete cases and implement the algorithm. Even if the algorithm seems to "make sense" in generality, applying an algorithm in a concrete case helps you understand subtle cases and edge cases.

It's likely that the professor already encourages implementing algorithms through projects and homework, so take advantage of it. If you can't implement the algorithm from scratch, it means you still don't have a full grasp of it.

#### Rule 3.2: Understand the Problem

Often students learn a framework, tool, practice for two main reasons.

1. Hype: Keep up with current trends
2. Best Practice: Learn the field's standards

Both are **valid** reasons for learning. Especially, as a newcomer to the field, it's advised to follow the established "Best Practices". Yet, it is **essential** to understand the reason why certain frameworks, tools, and practices are getting traction and why certain choices became "Best Practices".

Every framework, tool, practice in Computer Science is a response to address a problem in the field.

- The Microservice architecture was proposed to address the issue of scalability in Monolithic architecture
- Git was proposed to improve coordination of tasks between developers
- GraphQL was proposed to address the problem of data fetching in REST APIs
- Agile development was introduced to speed up the development cycle in response to the waterfall model and lean startup methodology.

Without understanding the context, it's difficult to decide strategically which technology is worth investing your time.

#### Rule 3.3: Praise Github

[Github](https://github.com/) is an ESSENTIAL tool for every developer. In a nutshell, it's a platform where developers can host source code for projects. There are many reasons why it became a predominant tool in software development, but here are the main reasons why a newcomer should learn GitHub:

1. Keep a record of code changes
2. Facilitate collaboration between fellow developers
3. Entry to Open Source community
4. Developer Portfolio

A direct reason to learn GitHub is that it keeps a record of code changes online and prevents unfortunate instances where a dog eats your code or computer breaks down the day before the deadline. Moreover, having multiple developers work on a single codebase simultaneously is not an easy task, and GitHub addresses that issue quite well.

Many open-source projects are hosted on GitHub and contributing to open source projects is a good entry to experiencing how developers collaborate and run communities. Lastly, as a dessert, a GitHub profile serves as a great portfolio!

### Rule 3.4: Embrace the Cloud

Cloud Computing is the current paradigm of computing. COVID-19 has accelerated the adoption of cloud computing in companies and it has become an infrastructure of choice for start-ups. It's a well-known fact that Netflix's and Dropbox's growth was supported by AWS's computing power. With its expanding role and impact, harnessing the power of the cloud is a strong skill set to possess for the coming decade.

[AWS](https://aws.amazon.com/), [Azure](https://azure.microsoft.com/en-us/), [GCP](https://cloud.google.com/) offer wide range of services from Storage, Hosting, AI/ML, Database, and even [Quantum computing](https://aws.amazon.com/braket/). Major cloud providers have a free-tier plan to start tinkering [creative](https://www.youtube.com/watch?v=q-nvbuc59Po) products with the power of the cloud. Explore and play around with it!

### Rule 3.5: Build a product

At the end of the day, a developer is a builder. Our task is to build, test, and "deploy" a product to the general public. There's a huge difference between a developer who has only built programs that run on "one" computer and a developer who has built and deployed a product to an end-user.

For a web developer, deploy a TODO list web application! For an ML engineer, train and deploy a logistic regression model as web API! For a mobile developer, deploy a weather app to iOS/Android!

Start with a minimal product.

### Rule 3.6: Humanities

In the end, humans build computers to help humans. Philosophy, Literature, Economics, Business, Art, and History are what constitute our understanding of society and humanity. The study of science has always had social, historical, and ethical implications in our society. Facebook has introduced new methods of social interaction. Amazon has restructured commerce. Google has exploded the flow of information and knowledge.

Now, with AI/ML integrating with modern society, it's becoming evident that computer scientists are no longer independent of ["human problems"](https://www.theverge.com/2018/1/12/16882408/google-racist-gorillas-photo-recognition-algorithm-ai). Having a perspective outside of the scope of mathematics and science is a prerequisite for responsibility.

### Rule 3.7: Stay Hungry, Stay Foolish

The landscape is constantly changing. No matter how young or old a person is, people have insights and experience that complements your own. Never stop learning. Arrogance and Pride are poison.
