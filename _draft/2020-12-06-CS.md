---
layout: single
title: "To Newcomers in CS"
classes: wide
---

Every year, hundreds, thousands, and millions of students enter university to study _Computer Science_. Reasons for deciding to study computer science are different. However, it's undeniable that CS enrollment has been increasing fueled by _"hype"_ growing role of computing in modern society. The steam generated by media hype and exponential growth has clouded the current landscape of computing. As a result, newcomers to the field of CS are greeted with a confusing scene where students are introduced with theory, tools, and practices in computing, but have no clear understanding of how these components fit together.

Navigating through this field is difficult. The goal of this article is to paint a landscape of computer science and distill lessons I have learned over years of studying in these fields. But, firstly, I would like to clarify misconceptions that fresh young minds may have about CS.

## Misconceptions about CS

### Coding is not for everyone

Firstly, I DO NOT believe that "Everyone can code". Yes, even a cat can walk over my keyboard and type a sensible, compilable code given enough time. The question is "Can everyone become a good coder?" The answer is "NO". Given enough practice and patience, "anyone" can indeed become a good coder, but an individual also has to find passion in coding.

From personal experience, coders find passion in problems and questions that others find mundane.

Let's take a look at following grid:

![percolation](https://michaeltoth.me/images/percolation.png){: .align-center }

Imagine that a stream of water is flowing top to bottom. In our grid, water would be able to flow from top and exit to the bottom. Now, given a grid, can we build a program that checks whether a water can penetrate to the bottom? If so, what would be the fastest algorithm? Can we prove the our algorithm is most efficient? How can we make it use less memory?

**Most importantly, does this problem sound exciting to you?**

These are problems and questions that computer scientists are intrested in exloring. We find enjoyment in optimizting and finding elegant solutions in computational problems, but it's understandable that not "everyone" might find it so fascinating.

Surely, everyone can code, but not everyone will find passion in coding.

### Coding is paintful

Coding is painful. Often in media, I see that programmers are portrayed in the following manner.

![typing](https://i.pinimg.com/originals/0f/b9/4d/0fb94dff52a5935e105ec497a0c010a5.gif){: .align-center }

Apart from the fact that movie directors think speed of typing correlates with one's ability to write good code, this portrayal is far from daily life of coders.

Computers are simplistic, deterministic machines. Naturally, these devils are brutally honest about our mistakes. One mistyped semi-colon, one line, one file can break the entire system. You're constantly battling against infinite stream of bugs. For most parts, developers spend their time staring at a monitor in distress hunting down bugs, trapped in perpetual cycle of pain and suffering.

However, the resolution at the end is truly rewarding. It's a genuinely satisfying to struggle hours, days, and weeks on a problem in determination and finally see your program run successfully. Moreover, it's a true pleasure to slowly, but steadily get closer and closer to the root cause of a problem. It's almost comparable to solving a murder case except the victim is one's mental sanity.

**Coding is a marathon, not a sprint.** It takes determination and patience to sit down for hours debugging and testing, but for those who can endure and push through frustration, coding is nothing short of pure entertainment.

## Rules of the Game

### Life

#### Rule 1: Time is Gold

Time is Gold.

#### Rule 2: Be honest

Seriouly, be honest. Not just with academically, but with yourself.

Don't lie to yourself that you're on track when you're procranating.

Don't lie to yourself that you're ready for an exam when you're really not.

Don't lie to yourself that you're satisfied with your grades, when you want to do better.

Don't lie to yourself that you're fine when you've been pulling all-nighters.

Don't lie to yourself. You know damn well what you really want.

#### Rule 14: Sleep

Lack of sleep is a constant problem for any university student.

#### Rule 9: Work is Sacred

Seperating WORK and REST is essential. Often, people claim that they're "working" while checking social media every 5 minutes or chatting with their friends once in a while. This form of "work" extends the work hours. As a consequence, you find yourself working past midnight. Although, you've taken breaks here and there while you were working, you feel that you're still exhausted because they weren't proper breaks.

Try to maintain "uninterrupted" work and "uninterrupted" breaks. I'm not implying that you have to work 3~4 hours straight, take 10~30 minutes of breaks in between. But, when you're working, focus sorely on your work, and when you're taking a break, sorely focus on resting.

Properly separating work and break makes work time shorter and more productive and makes the break feel well-deserved.

#### Rule 10: Self-Engineering

To be brutally frank, I'm lazy. I really am. However, I've researched myself enough so that I know how to "engineer" my behavior.

For instance, as a developer, it's hard to focus on work when most of your work is done on a "computer", a main medium of distraction. I often promise myself that I shouldn't drift off, but 5 minutes later, I'm on YouTube. Solution? I installed a site-blocker to block off YouTube and E-mail while I'm working.

Another example, I always put my alarm clock out of reach before going to sleep because I know too well that I'll turn it off and go to sleep if it's within my reach. Making self-promises and commitments are important, but put measures to enforce those commitments.

Do I trust myself? Probably Not. But, can I engineer myself? Yes.

#### Rule 11: Drink Coffee

Coffee is good, Good is Coffee.

### Learning

#### Rule 10: Replicate knowledge

Way too often, there're students who think reading through their notes and nodding their heads is enough to truly understand the content. Here's a simple accessment to check whether a person "truly" understands a concept.

> Take a blank of sheet of paper, and write down what you know about the concept.
> What you have in the blank piece of paper is what you "truly" understand.

By the end of a course, try lying back on your bed with eyes closed and try to replicate everything you have learned from first day to the last day of class. Not only this is a perfect way to organize what you've learned in the course, but also a realistic indicator of what you've learned.

#### Rule 12: Organize knowledge

Knowledge is not an array of random facts. Make a single cheatsheets

#### Rule 13: Be a Teacher

Teaching a concept to another person has always helped myself to stay sharp on the subject. The reason is simple. In order to teach a concept, you must have a perfect grasp on the topic.

#### Rule 10: Preview, Review

I know it sounds cliche, but preview and review the content before going to class. Going into class already having a basic understanding of content makes hard classes a lot easier to digest and follow up. Moreover, it ultimately saves you time because you're not left confused in middle of class to bearly keep up with content.

### Computer Science

#### Rule 6: Practice makes perfect

In Computer Science, students are presented with algorithms in abstract, generic description. But, try to apply the algorithm on concrete cases and implement the algorithm. It's likely that the professor already encourages implementing algorithms through projects and homework, so take advantage of it. If you can't implement the algorithm from scratch, or at least replicate its process on specific examples, it means you still don't have a full grasp of it.

#### Rule 2: Understand the Problem

One trend I see with

#### Rule 3: Learn Github

[Github](https://github.com/) is an ESSENTIAL tool for every developer. GitHub

1. Keep record of code changes
2. Collaboration

### Rule 4: Embrace the Cloud

[AWS](https://aws.amazon.com/), [Azure](https://azure.microsoft.com/en-us/), [GCP](https://cloud.google.com/)

### Rule 5: Test, test, test

[Testing](https://en.wikipedia.org/wiki/Software_testing)

### Rule 7: Build a product

### Rule 8: Humanities matter
